from _typeshed import Incomplete
from collections import MutableSet
from collections.abc import Generator

class IndexedSet(MutableSet):
    item_index_map: Incomplete
    item_list: Incomplete
    dead_indices: Incomplete
    def __init__(self, other: Incomplete | None = ...) -> None: ...
    def __len__(self): ...
    def __contains__(self, item): ...
    def __iter__(self): ...
    def __reversed__(self): ...
    def __eq__(self, other): ...
    @classmethod
    def from_iterable(cls, it): ...
    def add(self, item) -> None: ...
    def remove(self, item) -> None: ...
    def discard(self, item) -> None: ...
    def clear(self) -> None: ...
    def isdisjoint(self, other): ...
    def issubset(self, other): ...
    def issuperset(self, other): ...
    def union(self, *others): ...
    def iter_intersection(self, *others) -> Generator[Incomplete, None, None]: ...
    def intersection(self, *others): ...
    def iter_difference(self, *others) -> Generator[Incomplete, None, None]: ...
    def difference(self, *others): ...
    def symmetric_difference(self, *others): ...
    __or__: Incomplete
    __ror__: Incomplete
    __and__: Incomplete
    __rand__: Incomplete
    __sub__: Incomplete
    __xor__: Incomplete
    __rxor__: Incomplete
    def __rsub__(self, other): ...
    def update(self, *others) -> None: ...
    def intersection_update(self, *others) -> None: ...
    def difference_update(self, *others) -> None: ...
    def symmetric_difference_update(self, other) -> None: ...
    def __ior__(self, *others): ...
    def __iand__(self, *others): ...
    def __isub__(self, *others): ...
    def __ixor__(self, *others): ...
    def iter_slice(self, start, stop, step: Incomplete | None = ...): ...
    def __getitem__(self, index): ...
    def pop(self, index: Incomplete | None = ...): ...
    def count(self, val): ...
    def reverse(self) -> None: ...
    def sort(self, **kwargs) -> None: ...
    def index(self, val): ...

def complement(wrapped): ...

class _ComplementSet:
    def __init__(self, included: Incomplete | None = ..., excluded: Incomplete | None = ...) -> None: ...
    def complemented(self): ...
    __invert__: Incomplete
    def complement(self) -> None: ...
    def __contains__(self, item): ...
    def add(self, item) -> None: ...
    def remove(self, item) -> None: ...
    def pop(self): ...
    def intersection(self, other): ...
    def __and__(self, other): ...
    __rand__: Incomplete
    def __iand__(self, other): ...
    def union(self, other): ...
    def __or__(self, other): ...
    __ror__: Incomplete
    def __ior__(self, other): ...
    def update(self, items) -> None: ...
    def discard(self, items) -> None: ...
    def symmetric_difference(self, other): ...
    def __xor__(self, other): ...
    __rxor__: Incomplete
    def symmetric_difference_update(self, other) -> None: ...
    def isdisjoint(self, other): ...
    def issubset(self, other): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def issuperset(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def difference(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def difference_update(self, other) -> None: ...
    def __isub__(self, other): ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def __len__(self): ...
    def __iter__(self): ...
    def __bool__(self): ...
    __nonzero__: Incomplete
