from _typeshed import StrOrBytesPath
from collections.abc import Callable, Generator, Iterable
from types import TracebackType
from typing import IO, Any, NoReturn
from typing_extensions import TypeAlias

_PathReturn: TypeAlias = Any

def mkdir_p(path: StrOrBytesPath) -> NoReturn: ...

class FilePerms:
    user: str
    group: str
    other: str
    def __init__(self, user: str = ..., group: str = ..., other: str = ...) -> None: ...
    @classmethod
    def from_int(cls, i: int) -> FilePerms: ...
    @classmethod
    def from_path(cls, path: StrOrBytesPath) -> FilePerms: ...
    def __int__(self) -> int: ...

def atomic_save(dest_path: str, **kwargs) -> AtomicSaver: ...

class AtomicSaver:
    dest_path: str
    overwrite: bool
    file_perms: int
    overwrite_part: bool
    part_filename: str
    rm_part_on_exc: bool
    text_mode: bool
    buffering: int
    dest_dir: StrOrBytesPath
    part_path: StrOrBytesPath
    mode: str
    open_flags: int
    part_file: str
    def __init__(self, dest_path: str, **kwargs) -> NoReturn: ...
    def setup(self) -> NoReturn: ...
    def __enter__(self) -> IO[Any] | None: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None
    ) -> NoReturn: ...

def iter_find_files(
    directory: str, patterns: str | list[Any], ignored: str | list[Any] | None = ..., include_dirs: bool = ...
) -> Generator[str, None, None]: ...
def copy_tree(
    src: StrOrBytesPath,
    dst: StrOrBytesPath,
    symlinks: bool = ...,
    ignore: None | Callable[[str, list[str]], Iterable[str]] | Callable[[StrOrBytesPath, list[str]], Iterable[str]] = ...,
) -> _PathReturn: ...

copytree = copy_tree
file = object

class DummyFile(file):
    name: str
    mode: str
    closed: bool
    errors: list[str]
    isatty: bool
    encoding: str
    newlines: list[str]
    softspace: int
    def __init__(self, path: StrOrBytesPath, mode: str = ..., buffering: int | None = ...) -> None: ...
    def close(self) -> NoReturn: ...
    def fileno(self) -> int: ...
    def flush(self) -> NoReturn: ...
    def next(self) -> NoReturn: ...
    def read(self, size: int = ...) -> str: ...
    def readline(self, size: int = ...) -> str: ...
    def readlines(self, size: int = ...) -> list[str]: ...
    def seek(self) -> NoReturn: ...
    def tell(self) -> int: ...
    def truncate(self) -> NoReturn: ...
    def write(self, string: str) -> NoReturn: ...
    def writelines(self, list_of_strings: list[str]) -> None: ...
    def __next__(self) -> NoReturn: ...
    def __enter__(self) -> NoReturn: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> NoReturn: ...
